<!DOCTYPE html>
<html lang="zh-hans">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, maximum-scale=1" />
  <meta name="author" content="RaoPengYuan">
  <meta name="description" content="spring学习第四天">
  
  <meta property="og:title" content="spring学习第四天" />
<meta property="og:description" content="spring学习第四天" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://nowglow.github.io/blog/2019-06/spring%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E5%A4%A9/" />
<meta property="article:published_time" content="2019-06-29T00:14:19&#43;08:00"/>
<meta property="article:modified_time" content="2019-06-29T00:14:19&#43;08:00"/>



  <title>
  
       spring学习第四天 | Nightglow&#39;s Blog 
  
  </title>

  <link rel="canonical" href="https://nowglow.github.io/blog/2019-06/spring%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E5%A4%A9/">

  
  

  
  <link href="https://nowglow.github.io/css/vendors-extensions/fontawesome/all.min.css" rel="stylesheet">

  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Ubuntu+Mono:400,400i,700,700i|Raleway:300,400,500,600">
  <link href="https://nowglow.github.io/css/font.css" rel="stylesheet"> 
    
  
  <link href="https://nowglow.github.io/css/vendors/bootstrap4/bootstrap.min.css" rel="stylesheet">
  <link href="https://nowglow.github.io/css/vendors-extensions/mdb/mdb.min.css" rel="stylesheet"> 
  <link href="https://nowglow.github.io/css/vendors/mdb/style.min.css" rel="stylesheet"> 
  <link href="https://nowglow.github.io/css/main.css" rel="stylesheet">


  
  <link rel="shortcut icon"
  
      href="https://nowglow.github.io/img/profile2.jpg"
  
  >


  
  

  <style type="text/css">
      @media (min-width: 800px) and (max-width: 850px) {
              .navbar:not(.top-nav-collapse) {
                  background: #1C2331!important;
              }
          }
  </style>


  
    
    <link rel="stylesheet" href="https://nowglow.github.io/js/vendors/katex/katex.min.css">
  
  

  
    
    <link rel="stylesheet" href="https://nowglow.github.io/css/vendors/highlight/github-gist.css">
  

</head>

  <body class="bg-light" data-spy="scroll" data-target="#page-scrollspy" data-offset="90">
  
    
    

    
      


<nav class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar">
    <div class="container">

      
      <a class="navbar-brand" href="https://nowglow.github.io/">
          
        <img class="avatar" src="https://nowglow.github.io/" style="width: 40px!important;height: auto;"  class="d-inline-block align-top" alt="" >
        
        <strong> RaoPengYuan</strong>
      </a>

      
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent"
        aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      
      <div class="collapse navbar-collapse" id="navbarSupportedContent">

        
        <ul class="navbar-nav mr-auto ">
          <li class="nav-item ">
            <a class="nav-link" href="https://nowglow.github.io/">Home</a>
          </li>
             
            <li class="nav-item ">
              <a class="nav-link" href="https://nowglow.github.io/blog/" >Blog  </a>
            </li>
          
             
            <li class="nav-item ">
              <a class="nav-link" href="https://nowglow.github.io/about/" >About  </a>
            </li>
          
          
        </ul>

      </div>

    </div>
  </nav>
  
 
      
 






<div id="site-header" class="carousel slide carousel-fade" data-ride="carousel" style="height: 18rem;" >  

  
  
  

  
  <div class="carousel-inner" role="listbox">
    
      

        
        <div class="carousel-item active">
          <div class="view" style="background-image: url('https://nowglow.github.io/img/header-slides/raw_1515691746.jpg'); background-repeat: no-repeat; background-size: cover;">

            
            <div class="mask rgba-black-light d-flex justify-content-center align-items-center">

              
              
              

            </div>
            

          </div>
        </div>
        
      
    
      

        
        <div class="carousel-item">
          <div class="view" style="background-image: url('https://nowglow.github.io/img/header-slides//raw_1515847341.jpg'); background-repeat: no-repeat; background-size: cover;">

            
            <div class="mask rgba-black-light d-flex justify-content-center align-items-center">

            

            </div>
            

          </div>
        </div>
        
      
    

  
  </div>
  

  
  <div class="carousel-content text-center white-text wow fadeIn">
    <div class="row mx-0 headfont mt-3 pt-4">
      
      <div class="col-12 col-sm-5 align-middle">
        <a href="https://nowglow.github.io/">
          
            <img class="pull-right avatar avatar-md" src="https://nowglow.github.io/img/profile2.jpg" alt="" >
          
        </a>
      </div>
      
      <div class="col-12 col-sm-7 text-left pl-2">
        <a href="https://nowglow.github.io/">
          <h1 class="mb-2 h1" style="font-weight: 300;" >
            <strong>Nightglow&#39;s Blog</strong>
          </h1>
        </a>
        

             
        <div class="mt-2" style="font-size: 1rem; color: white;">
            
              <a href="//github.com/nowglow" target="_blank" rel="noopener"><i class="fab fa-github pr-1" aria-hidden="true"></i></a>    
            
            

            

            

            

            
    
            
    
        
            
                <a href="mailto:raopengyuan@aliyun.com"><i class="far fa-envelope-open pr-1" aria-hidden="true"></i></a>
            
    
            

            
        </div>
      </div>
    </div>
  </div>
  

  
  
  

</div>
  
    

    
  
  <main class="post-main-wrapper">
    
    
    <div class="row">

      

      
      <div class="col-md-10">
      

        
        <div class="z-depth-1  post-wrapper white-bg single-post">

          <div class="post-header text-center" >
  <ul class="post-meta li-x">
    
      
        <li><a href="https://nowglow.github.io/categories/spring"><i class="fas fa-folder-open pr-1" aria-hidden="true"></i> Spring </a></li>
      
    
    
      
        <li><a href="https://nowglow.github.io/series/spring"><i class="fas fa-bookmark pr-1" aria-hidden="true"></i>Spring</a></li>
      
    
  </ul>

  <div class="px-4 post-heading">spring学习第四天</div>

  <ul class="post-meta li-x mt-1">
    
      <li>Jun 29, 2019</li>
    

    
      <li class="middot"></li>
      <li>13 minutes read</li>
    
  </ul>
  

</div>


          <div class="post-content markdown">
            

<h2 id="aop的概述">AOP的概述</h2>

<h2 id="什么是aop">什么是AOP</h2>

<ul>
<li>AOP Aspect Oriented Programing 面向切面编程</li>
<li>AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码（性能监视、事务管理、安全检查、缓存）</li>
<li>Spring AOP使用纯Java实现，不需要专门的编译过程和类加载器，在运行期通过代理方式向目标类织入增强代码</li>
<li>AspecJ是一个基于Java语言的AOP框架，Spring2.0开始，Spring AOP引入对Aspect的支持，AspectJ扩展了Java语言，提供了一个专门的编译器，在编译时提供横向代码的织入</li>
</ul>

<h2 id="aop底层原理">AOP底层原理</h2>

<ul>
<li>代理机制:</li>
<li>动态代理:(JDK中使用)</li>

<li><p>JDK的动态代理,对实现了接口的类生成代理.</p>

<h2 id="spring的aop代理">Spring的AOP代理</h2></li>

<li><p>JDK动态代理:对实现了接口的类生成代理</p></li>

<li><p>CGLib代理机制:对类生成代理</p>

<h2 id="aop的术语">AOP的术语</h2></li>

<li><p>Joinpoint(连接点):所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点.</p></li>

<li><p>Pointcut(切入点):所谓切入点是指我们要对哪些Joinpoint进行拦截的定义.</p></li>

<li><p>Advice(通知/增强):所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能)</p></li>

<li><p>Introduction(引介):引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field.</p></li>

<li><p>Target(目标对象):代理的目标对象</p></li>

<li><p>Weaving(织入):是指把增强应用到目标对象来创建新的代理对象的过程.</p></li>

<li><p>spring采用动态代理织入，而AspectJ采用编译期织入和类转载期织入</p></li>

<li><p>Proxy（代理）:一个类被AOP织入增强后，就产生一个结果代理类</p></li>

<li><p>Aspect(切面): 是切入点和通知（引介）的结合</p></li>
</ul>

<h2 id="aop的底层实现">AOP的底层实现</h2>

<h2 id="jdk动态代理">JDK动态代理</h2>

<ul>
<li><p>UserDao &amp; UserDaoImpl</p>

<p>public interface UserDao {
    public void add();
    public void update();
}</p>

<p>public class UserDaoImpl implements UserDao {</p>

<pre><code>public void add() {
    System.out.println(&quot;添加用户...&quot;);
}

public void update() {
    System.out.println(&quot;修改用户...&quot;);
}
</code></pre>

<p>}</p>

<pre><code>@Test
public void demo2(){
    // 被代理对象
    UserDao userDao = new UserDaoImpl();
    // 创建代理对象的时候传入被代理对象.
    UserDao proxy = new JDKProxy(userDao).createProxy();
    proxy.add();
    proxy.update();
}
</code></pre></li>

<li><p>JDK动态代理</p>

<p>public class JDKProxy implements InvocationHandler{
    private UserDao userDao;</p>

<pre><code>public JDKProxy(UserDao userDao) {
    super();
    this.userDao = userDao;
}

public UserDao createProxy() {
    UserDao proxy = (UserDao) Proxy.newProxyInstance(userDao.getClass()
            .getClassLoader(), userDao.getClass().getInterfaces(), this);
    return proxy;
}

// 调用目标对象的任何一个方法 都相当于调用invoke();
public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable {
    if(&quot;add&quot;.equals(method.getName())){
        // 记录日志:
        System.out.println(&quot;日志记录=================&quot;);
        Object result = method.invoke(userDao, args);
        return result;
    }
    return method.invoke(userDao, args);
}
</code></pre>

<p>}</p></li>
</ul>

<h2 id="cglib动态代理">CGLIB动态代理</h2>

<ul>
<li>CGLIB(Code Generation Library)是一个开源项目！是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。 Hibernate支持它来实现PO(Persistent Object 持久化对象)字节码的动态生成</li>
<li></li>
<li>CGLIB生成代理机制:CGlib采用非常底层字节码技术，可以为一个类创建子类，解决无接口代理问题</li>
<li></li>
<li>现在做cglib的开发,可以不用直接引入cglib的包.已经在spring的核心中集成cglib.</li>
<li></li>
<li>关于intercept拦截方法</li>
<li>

<ul>
<li>@param obj CGlib根据指定父类生成的代理对象</li>
<li>@param method 拦截的方法</li>
<li>@param args 拦截方法的参数数组</li>
<li>@param proxy 方法的代理对象，用于执行父类的方法</li>
</ul></li>

<li><p>@return</p>

<p>public Object intercept(Object obj, Method method, Object[] args,
MethodProxy proxy) throws Throwable {
… …
}</p>

<p>public class CGLibProxy implements MethodInterceptor{
private ProductDao productDao;</p>

<p>public CGLibProxy(ProductDao productDao) {
    super();
    this.productDao = productDao;
}</p>

<p>public ProductDao createProxy(){</p>

<pre><code>// 使用CGLIB生成代理:

// 1.创建核心类:
Enhancer enhancer = new Enhancer();

// 2.为其设置父类:
enhancer.setSuperclass(productDao.getClass());

// 3.设置回调:
enhancer.setCallback(this);

// 4.创建代理:
return (ProductDao) enhancer.create();
</code></pre>

<p>}</p>

<p>public Object intercept(Object proxy, Method method, Object[] args,MethodProxy methodProxy) throws Throwable {</p>

<pre><code>if(&quot;add&quot;.equals(method.getName())){
    System.out.println(&quot;日志记录==============&quot;);
    Object obj = methodProxy.invokeSuper(proxy, args);
    return obj;
}

return methodProxy.invokeSuper(proxy, args);
</code></pre>

<p>}
}</p>

<p>//SpringTest
    @Test
    public void demo2(){
        ProductDao productDao = new ProductDao();
        ProductDao proxy = new CGLibProxy(productDao).createProxy();
        proxy.add();
        proxy.update();
    }</p></li>

<li><p>结论 : Spring框架,如果类实现了接口,就使用JDK的动态代理生成代理对象,如果这个类没有实现任何接口,使用CGLIB生成代理对象</p></li>
</ul>

<h2 id="代理知识总结">代理知识总结</h2>

<ul>
<li>Spring在运行期，生成动态代理对象，不需要特殊的编译器</li>
<li>Spring AOP的底层就是通过JDK动态代理或CGLib动态代理技术 为目标Bean执行横向织入

<ul>
<li>1.若目标对象实现了若干接口，spring使用JDK的java.lang.reflect.Proxy类代理。</li>
<li>2.若目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类。</li>
</ul></li>
<li>程序中应优先对接口创建代理，便于程序解耦维护</li>
<li>标记为final的方法，不能被代理，因为无法进行覆盖</li>
<li>JDK动态代理，是针对接口生成子类，接口中方法不能使用final修饰</li>
<li>CGLib 是针对目标类生产子类，因此类或方法 不能使final的</li>

<li><p>Spring只支持方法连接点，不提供属性连接</p>

<h2 id="spring中的aop">Spring中的AOP</h2>

<h2 id="spring的传统aop">Spring的传统AOP</h2></li>

<li><p>AOP:不是由Spring定义.由AOP联盟的组织定义.</p>

<h2 id="spring中的通知-增强类型">Spring中的通知(增强类型)</h2></li>

<li><p>AOP联盟为通知Advice定义了org.aopalliance.aop.Interface.Advice</p></li>

<li><p>Spring按照通知Advice在目标类方法的连接点位置，可以分为5类</p></li>

<li></li>

<li><p>前置通知 org.springframework.aop.MethodBeforeAdvice</p></li>

<li><ul>
<li>在目标方法执行前实施增强</li>
</ul></li>

<li><p>后置通知 org.springframework.aop.AfterReturningAdvice</p>

<ul>
<li>在目标方法执行后实施增强</li>
</ul></li>

<li><p>环绕通知 org.aopalliance.intercept.MethodInterceptor</p>

<ul>
<li>在目标方法执行前后实施增强</li>
</ul></li>

<li><p>异常抛出通知 org.springframework.aop.ThrowsAdvice</p>

<ul>
<li>在方法抛出异常后实施增强</li>
</ul></li>

<li><p>引介通知 org.springframework.aop.IntroductionInterceptor(课程不讲.)</p>

<ul>
<li><p>在目标类中添加一些新的方法和属性</p>

<h2 id="spring中的切面类型">Spring中的切面类型</h2></li>
</ul></li>

<li><p>Advisor : Spring中传统切面.代表一般切面，Advice本身就是一个切面，对目标类所有方法进行拦截</p>

<ul>
<li>Advisor:都是有一个切点和一个通知组合.</li>
</ul></li>

<li><p>Aspect:多个切点和多个通知组合.</p></li>

<li></li>

<li><p>PointcutAdvisor : 代表具有切点的切面，可以指定拦截目标类哪些方法(带有切点的切面,针对某个方法进行拦截)</p></li>

<li></li>

<li><p>IntroductionAdvisor : 代表引介切面，针对引介通知而使用切面（不要求掌握）</p></li>
</ul>

<h2 id="spring的aop的开发">Spring的AOP的开发</h2>

<h2 id="针对所有方法的增强-不带有切点的切面">针对所有方法的增强:(不带有切点的切面)</h2>

<ul>
<li>第一步:导入相应jar包.

<ul>
<li>spring-aop-3.2.0.RELEASE.jar</li>
<li>com.springsource.org.aopalliance-1.0.0.jar</li>
</ul></li>
<li>第二步:编写被代理对象:

<ul>
<li>CustomerDao接口</li>
<li>CustoemrDaoImpl实现类</li>
</ul></li>

<li><p>第三步:编写增强的代码:</p>

<p>public class MyBeforeAdvice implements MethodBeforeAdvice{</p>

<p>/**</p>

<ul>
<li>method:执行的方法</li>
<li>args:参数</li>
<li>target:目标对象
*/
<br /></li>
</ul>

<p>public void before(Method method, Object[] args, Object target)
        throws Throwable {
    System.out.println(&ldquo;前置增强&hellip;&rdquo;);
}
}</p></li>

<li><p>第四步:生成代理:(配置生成代理)</p>

<ul>
<li>生成代理Spring基于ProxyFactoryBean类.底层自动选择使用JDK的动态代理还是CGLIB的代理.</li>
<li>属性:</li>
<li>target : 代理的目标对象</li>
<li>proxyInterfaces : 代理要实现的接口</li>

<li><p>如果多个接口可以使用以下格式赋值</p>

<p><list>
    <value></value>
    &hellip;.
</list></p>

<ul>
<li>proxyTargetClass : 是否对类代理而不是接口，设置为true时，使用CGLib代理</li>
<li>interceptorNames : 需要织入目标的Advice</li>
<li>singleton : 返回代理是否为单实例，默认为单例</li>
<li>optimize : 当设置为true时，强制使用CGLib</li>
</ul></li>
</ul></li>

<li><p>applicationContext.xml
    <!-- 定义目标对象 -->
    <bean id="customerDao" class="cn.itcast.spring3.demo3.CustomerDaoImpl"></bean></p>

<pre><code>&lt;!-- 定义增强 --&gt;
&lt;bean id=&quot;beforeAdvice&quot; class=&quot;cn.itcast.spring3.demo3.MyBeforeAdvice&quot;&gt;&lt;/bean&gt;

&lt;!-- Spring支持配置生成代理: --&gt;
&lt;bean id=&quot;customerDaoProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;

    &lt;!-- 设置目标对象 --&gt;
    &lt;property name=&quot;target&quot; ref=&quot;customerDao&quot;/&gt;

    &lt;!-- 设置实现的接口 ,value中写接口的全路径 --&gt;
    &lt;property name=&quot;proxyInterfaces&quot; value=&quot;cn.itcast.spring3.demo3.CustomerDao&quot;/&gt;

    &lt;!-- 需要使用value:要的名称 --&gt;
    &lt;property name=&quot;interceptorNames&quot; value=&quot;beforeAdvice&quot;/&gt;
&lt;/bean&gt;
</code></pre></li>

<li><p>注入的时候要注入代理对象:</p>

<p>@Autowired
// @Qualifier(&ldquo;customerDao&rdquo;)// 注入是真实的对象,必须注入代理对象.
@Qualifier(&rdquo;<strong>customerDaoProxy</strong>&rdquo;)
private CustomerDao customerDao;</p></li>
</ul>

<h2 id="带有切点的切面-针对目标对象的某些方法进行增强">带有切点的切面:(针对目标对象的某些方法进行增强)</h2>

<ul>
<li><p>常用PointcutAdvisor 实现类</p>

<ul>
<li>DefaultPointcutAdvisor 最常用的切面类型，它可以通过任意Pointcut和Advice 组合定义切面</li>
<li>RegexpMethodPointcutAdvisor 构造正则表达式切点切面</li>
</ul></li>

<li><p>第一步:创建被代理对象.</p>

<ul>
<li>OrderDao</li>
</ul></li>

<li><p>第二步:编写增强的类:</p>

<p>public class MyAroundAdvice implements MethodInterceptor{</p>

<p>public Object invoke(MethodInvocation methodInvocation) throws Throwable {</p>

<pre><code>System.out.println(&quot;环绕前增强...&quot;);
Object result = methodInvocation.proceed();// 执行目标对象的方法
System.out.println(&quot;环绕后增强...&quot;);
return result;
</code></pre>

<p>}
}</p></li>

<li><p>第三步:生成代理:</p>

<!-- 带有切点的切面 -->

<!-- 定义目标对象 -->

<p><bean id="orderDao" class="cn.itcast.spring3.demo4.OrderDao"></bean></p>

<!-- 定义增强 -->

<p><bean id="aroundAdvice" class="cn.itcast.spring3.demo4.MyAroundAdvice"></bean></p>

<!-- 定义切点切面: -->

<p><bean id="myPointcutAdvisor" class="org.springframework.aop.support.RegexpMethodPointcutAdvisor"></p>

<pre><code>&lt;!-- 定义表达式,规定哪些方法执行拦截 --&gt;
&lt;!-- . 任意字符  * 任意个 --&gt;
&lt;!-- &lt;property name=&quot;pattern&quot; value=&quot;.*&quot;/&gt; --&gt;
&lt;!-- &lt;property name=&quot;pattern&quot; value=&quot;cn\.itcast\.spring3\.demo4\.OrderDao\.add.*&quot;/&gt; --&gt;
&lt;!-- &lt;property name=&quot;pattern&quot; value=&quot;.*add.*&quot;&gt;&lt;/property&gt; --&gt;
&lt;property name=&quot;patterns&quot; value=&quot;.*add.*,.*find.*&quot;&gt;&lt;/property&gt;

&lt;!-- 应用增强 --&gt;
&lt;property name=&quot;advice&quot; ref=&quot;aroundAdvice&quot;/&gt;
</code></pre>

<p></bean></p>

<!-- 定义生成代理对象 -->

<p><bean id="orderDaoProxy" class="org.springframework.aop.framework.ProxyFactoryBean"></p>

<pre><code>&lt;!-- 配置目标 --&gt;
&lt;property name=&quot;target&quot; ref=&quot;orderDao&quot;&gt;&lt;/property&gt;

&lt;!-- 针对类的代理 --&gt;
&lt;property name=&quot;proxyTargetClass&quot; value=&quot;true&quot;&gt;&lt;/property&gt;

&lt;!-- 在目标上应用增强 --&gt;
&lt;property name=&quot;interceptorNames&quot; value=&quot;myPointcutAdvisor&quot;&gt;&lt;/property&gt;
</code></pre>

<p></bean></p></li>
</ul>

<h2 id="自动代理">自动代理</h2>

<ul>
<li>前面的案例中，每个代理都是通过ProxyFactoryBean织入切面代理，在实际开发中，非常多的Bean每个都配置ProxyFactoryBean开发维护量巨大。</li>
<li>自动创建代理(基于后处理Bean.在Bean创建的过程中完成的增强.生成Bean就是代理.)</li>
<li>BeanNameAutoProxyCreator 根据Bean名称创建代理</li>
<li>DefaultAdvisorAutoProxyCreator 根据Advisor本身包含信息创建代理</li>
<li>AnnotationAwareAspectJAutoProxyCreator 基于Bean中的AspectJ 注解进行自动代理</li>
</ul>

<h2 id="beannameautoproxycreator-按名称生成代理">BeanNameAutoProxyCreator :按名称生成代理</h2>

<pre><code>&lt;!-- 定义目标对象 --&gt;
&lt;bean id=&quot;customerDao&quot; class=&quot;cn.itcast.spring3.demo3.CustomerDaoImpl&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;orderDao&quot; class=&quot;cn.itcast.spring3.demo4.OrderDao&quot;&gt;&lt;/bean&gt;

&lt;!-- 定义增强 --&gt;
&lt;bean id=&quot;beforeAdvice&quot; class=&quot;cn.itcast.spring3.demo3.MyBeforeAdvice&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;aroundAdvice&quot; class=&quot;cn.itcast.spring3.demo4.MyAroundAdvice&quot;&gt;&lt;/bean&gt;

&lt;!-- 自动代理:按名称的代理 基于后处理Bean,后处理Bean不需要配置ID--&gt;
&lt;bean class=&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;&gt;
    &lt;property name=&quot;beanNames&quot; value=&quot;*Dao&quot;/&gt;**
    &lt;property name=&quot;interceptorNames&quot; value=&quot;beforeAdvice&quot;/&gt;**
&lt;/bean&gt;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath:applicationContext2.xml&quot;)
public class SpringTest5 {

    @Autowired
    @Qualifier(&quot;orderDao&quot;)
    private OrderDao orderDao;
    @Autowired
    @Qualifier(&quot;customerDao&quot;)
    private CustomerDao customerDao;    

    @Test
    public void demo1(){
        orderDao.add();
        orderDao.delete();

        customerDao.update();
    }
}



DefaultAdvisorAutoProxyCreator :根据切面中定义的信息生成代理
&lt;!-- 定义目标对象 --&gt;
&lt;bean id=&quot;customerDao&quot; class=&quot;cn.itcast.spring3.demo3.CustomerDaoImpl&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;orderDao&quot; class=&quot;cn.itcast.spring3.demo4.OrderDao&quot;&gt;&lt;/bean&gt;

&lt;!-- 定义增强 --&gt;
&lt;bean id=&quot;beforeAdvice&quot; class=&quot;cn.itcast.spring3.demo3.MyBeforeAdvice&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;aroundAdvice&quot; class=&quot;cn.itcast.spring3.demo4.MyAroundAdvice&quot;&gt;&lt;/bean&gt;

&lt;!--定义一个带有切点的切面 --&gt;
&lt;bean id=&quot;myPointcutAdvisor&quot; class=&quot;org.springframework.aop.support.RegexpMethodPointcutAdvisor&quot;&gt;**
    &lt;property name=&quot;pattern&quot; value=&quot;.*add.*&quot;/&gt;
    &lt;property name=&quot;advice&quot; ref=&quot;aroundAdvice&quot;/&gt;
&lt;/bean&gt;

&lt;!--自动生成代理 --&gt;

&lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;&gt;&lt;/bean&gt;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath:applicationContext3.xml&quot;)
public class SpringTest6 {
    @Autowired
    @Qualifier(&quot;orderDao&quot;)
    private OrderDao orderDao;
    @Autowired
    @Qualifier(&quot;customerDao&quot;)
    private CustomerDao customerDao;

    @Test
    public void demo1(){
        orderDao.add();
        orderDao.update();
        orderDao.delete();

        customerDao.add();
    }
}
</code></pre>

<ul>
<li>区分基于ProxyFattoryBean****的代理与自动代理区别?

<ul>
<li>ProxyFactoryBean:先有被代理对象,将被代理对象传入到代理类中生成代理.</li>
<li>自动代理基于后处理Bean.在Bean的生成过程中就产生了代理对象,把代理对象返回.生成Bean已经是代理对象</li>
</ul></li>
</ul>

<h2 id="使用aspectj实现aop">使用AspectJ实现AOP</h2>

<ul>
<li>AspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法所以它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。</li>
<li>AspectJ是一个基于Java语言的AOP框架</li>
<li>Spring2.0以后新增了对AspectJ切点表达式支持</li>
<li>@AspectJ 是AspectJ1.5新增功能，通过JDK5注解技术，允许直接在Bean类中定义切面</li>
<li>新版本Spring框架，建议使用AspectJ方式来开发AOP</li>
</ul>

<h2 id="aspectj表达式">AspectJ表达式</h2>

<ul>
<li>语法:execution(表达式)</li>
<li>execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;)</li>
<li>execution(“* cn.itcast.spring3.demo1.dao.*(..)”) —只检索当前包</li>
<li>execution(“* cn.itcast.spring3.demo1.dao..*(..)”) —检索包及当前包的子包.</li>
<li>execution(* cn.itcast.dao.GenericDAO+.*(..)) —检索GenericDAO及子类</li>
</ul>

<h2 id="aspectj的通知类型">AspectJ的通知类型</h2>

<ul>
<li>@Before 前置通知，相当于BeforeAdvice

<ul>
<li>就在方法之前执行.没有办法阻止目标方法执行的.</li>
</ul></li>
<li>@AfterReturning 后置通知，相当于AfterReturningAdvice

<ul>
<li>后置通知,获得方法返回值.</li>
</ul></li>
<li>@Around 环绕通知，相当于MethodInterceptor

<ul>
<li>在可以方法之前和之后来执行的,而且可以阻止目标方法的执行.</li>
</ul></li>
<li>@AfterThrowing 抛出通知，相当于ThrowAdvice</li>
<li>@After 最终final通知，不管是否异常，该通知都会执行</li>
<li>@DeclareParents 引介通知，相当于IntroductionInterceptor (不要求掌握)</li>
</ul>

<h2 id="基于注解方式配置切面">基于注解方式配置切面</h2>

<ul>
<li>第一步:引入相应jar包.</li>
<li>aspectj依赖aop环境,之前导入的AOP jar包需要继续导入。

<ul>
<li>spring-aop-3.2.0.RELEASE.jar</li>
<li>com.springsource.org.aopalliance-1.0.0.jar</li>
<li>spring-aspects-3.2.0.RELEASE.jar</li>
<li>com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar</li>
</ul></li>
<li>第二步:编写被增强的类:

<ul>
<li>UserDao</li>
</ul></li>
</ul>

<p>第三步:使用AspectJ注解形式:
    @Aspect
    public class MyAspect {
    @Before(&ldquo;execution(* cn.itcast.spring3.demo1.UserDao.add(..))&ldquo;)</p>

<pre><code>public void before(){
    System.out.println(&quot;前置增强....&quot;);
}
}
</code></pre>

<p>第四步:创建applicationContext.xml
引入aop的约束:
    &lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?&gt;
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:aop="http://www.springframework.org/schema/aop"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">
        <!-- 开启AspectJ自动代理--><br />
        <aop:aspectj-autoproxy />
    </beans></p>

<ul>
<li>开启AspectJ自动代理 : <aop:aspectj-autoproxy />

<ul>
<li>底层就是AnnotationAwareAspectJAutoProxyCreator</li>
</ul></li>

<li><p>定义目标类与切面类</p>

<p><bean id="userDao" class="cn.itcast.spring3.demo1.UserDao"></bean>
<bean id="myAspect" class="cn.itcast.spring3.demo1.MyAspect"></bean></p></li>
</ul>

<h2 id="常见切面类编写">常见切面类编写</h2>

<h2 id="before前置通知">@Before前置通知</h2>

<ul>
<li>可以在方法中传入JoinPoint对象，用来获得切点信息</li>
</ul>

<h2 id="afterreturing-后置通知">@AfterReturing 后置通知</h2>

<ul>
<li>通过returning属性 可以定义方法返回值，作为参数</li>
</ul>

<h2 id="around-环绕通知">@Around 环绕通知</h2>

<ul>
<li>around方法的返回值就是目标代理方法执行返回值</li>
<li>参数为ProceedingJoinPoint 可以调用拦截目标方法执行</li>
<li>重点：如果不调用 ProceedingJoinPoint的 proceed方法，那么目标方法就被拦截了</li>
</ul>

<h2 id="afterthrowing-抛出通知">@AfterThrowing 抛出通知</h2>

<ul>
<li>通过设置throwing属性，可以设置发生异常对象参数</li>
</ul>

<h2 id="after-最终通知">@After 最终通知</h2>

<pre><code>/**
 * 切面类:就是切点与增强结合
 * @author 姜涛
 *
 */
@Aspect
public class MyAspect {

@Before(&quot;execution(* cn.itcast.spring3.demo1.UserDao.add(..))&quot;)
public void before(JoinPoint joinPoint){
System.out.println(&quot;前置增强....&quot;+joinPoint);
}

@AfterReturning(value=&quot;execution(* cn.itcast.spring3.demo1.UserDao.update(..))&quot;,returning=&quot;returnVal&quot;)
public void afterReturin(Object returnVal){
System.out.println(&quot;后置增强....方法的返回值:&quot;+returnVal);
}

@Around(value=&quot;MyAspect.myPointcut()&quot;)
public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable{
System.out.println(&quot;环绕前增强....&quot;);
Object obj = proceedingJoinPoint.proceed();
System.out.println(&quot;环绕后增强....&quot;);
return obj;
}

@AfterThrowing(value=&quot;MyAspect.myPointcut()&quot;,throwing=&quot;e&quot;)
public void afterThrowing(Throwable e){
System.out.println(&quot;不好了 出异常了!!!&quot;+e.getMessage());
}

@After(&quot;MyAspect.myPointcut()&quot;)
public void after(){
System.out.println(&quot;最终通知...&quot;);
}

@Pointcut(&quot;execution(* cn.itcast.spring3.demo1.UserDao.find(..))&quot;)
private void myPointcut(){}
}
</code></pre>

<h2 id="通过-pointcut为切点命名">通过@Pointcut为切点命名</h2>

<ul>
<li>在每个通知内定义切点，会造成工作量大，不易维护，对于重复的切点，可以使用@Poingcut进行定义</li>
<li>切点方法：private void 无参数方法，方法名为切点名</li>

<li><p>当通知多个切点时，可以使用|| 进行连接</p></li>

<li><p>面试: Advisor和Aspect的区别?</p>

<ul>
<li>Advisor:Spring传统意义上的切面:支持一个切点和一个通知的组合.</li>
<li>Aspect:可以支持多个切点和多个通知的组合.</li>
</ul></li>
</ul>

<h2 id="使用xml配置切面">使用XML配置切面</h2>

<ul>
<li><p>第一步:编写被增强的类:</p>

<ul>
<li>ProductDao</li>
</ul></li>

<li><p>第二步:定义切面</p></li>

<li><p>第三步:配置applicationContext.xmll</p>

<h2 id="前置通知">前置通知</h2>

<p>public void before(){
    System.out.println(&ldquo;前置通知&hellip;&rdquo;);
}</p>

<p>配置:
<a href="aop:config">aop:config</a>
    <!-- 定义切点: -->
    <aop:pointcut expression="execution(* cn.itcast.spring3.demo2.ProductDao.add(..))" id="mypointcut"/></p>

<pre><code>&lt;aop:aspect ref=&quot;myAspectXML&quot;&gt;
    &lt;!-- 前置通知 --&gt;
    &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;mypointcut&quot;/&gt;
&lt;/aop:aspect&gt;
</code></pre>

<p><a href="https://nowglow.github.io/aop:config">/aop:config</a></p></li>
</ul>

<p>示例：</p>

<h2 id="后置通知">后置通知</h2>

<p>代码:
    public void afterReturing(Object returnVal){
        System.out.println(&ldquo;后置通知&hellip;返回值:&ldquo;+returnVal);
    }</p>

<p>配置:
    <a href="aop:config">aop:config</a>
        <!-- 定义切点: -->
        <aop:pointcut expression="execution(* cn.itcast.spring3.demo2.ProductDao.add(..))" id="mypointcut"/>
        <aop:aspect ref="myAspectXML"></p>

<pre><code>        &lt;!-- 后置通知 --&gt;
        &lt;aop:after-returning method=&quot;afterReturing&quot; pointcut-ref=&quot;mypointcut&quot; returning=&quot;returnVal&quot;/&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>

<p>示例：</p>

<h2 id="环绕通知">环绕通知</h2>

<pre><code>代码:
public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable{
    System.out.println(&quot;环绕前增强....&quot;);
    Object result = proceedingJoinPoint.proceed();
    System.out.println(&quot;环绕后增强....&quot;);
    return result;
}

配置:
&lt;aop:config&gt;

    &lt;!-- 定义切点: --&gt;
    &lt;aop:pointcut expression=&quot;execution(* cn.itcast.spring3.demo2.ProductDao.add(..))&quot; id=&quot;mypointcut&quot;/&gt;
    &lt;aop:aspect ref=&quot;myAspectXML&quot;&gt;
        &lt;!-- 环绕通知 --&gt;
        **&lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;mypointcut&quot;/&gt;**
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>

<p>示例：</p>

<h2 id="异常通知">异常通知</h2>

<pre><code>代码
public void afterThrowing(Throwable e){
    System.out.println(&quot;异常通知...&quot;+e.getMessage());
}

配置
&lt;aop:config&gt;

    &lt;!-- 定义切点: --&gt;
    &lt;aop:pointcut expression=&quot;execution(* cn.itcast.spring3.demo2.ProductDao.add(..))&quot; id=&quot;mypointcut&quot;/&gt;

    &lt;aop:aspect ref=&quot;myAspectXML&quot;&gt;
        &lt;!-- 异常通知 --&gt;
        &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;mypointcut&quot; throwing=&quot;e&quot;/&gt;
    &lt;/aop:aspect&gt;

&lt;/aop:config&gt;
</code></pre>

<p>示例：</p>

<h2 id="最终通知">最终通知</h2>

<pre><code>代码:
public void after(){
    System.out.println(&quot;最终通知....&quot;);
}

配置:
&lt;aop:config&gt;

    &lt;!-- 定义切点: --&gt;
    &lt;aop:pointcut expression=&quot;execution(* cn.itcast.spring3.demo2.ProductDao.add(..))&quot; id=&quot;mypointcut&quot;/&gt;

    &lt;aop:aspect ref=&quot;myAspectXML&quot;&gt;
        &lt;!-- 最终通知 --&gt;
        &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;mypointcut&quot;/&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>

          </div>

          
          <div class="row">
            <div class="col-md-8">
            
              <div class="mb-5">
                
<div class="li-x div-x post-meta">
  <li class="pr-0"><a href="https://nowglow.github.io/tags/"><i class="fas fa-tags"></i></a></li>
  <div class="tags-sm">
    
      <li><a href="https://nowglow.github.io/tags/spring" role="button">Spring </a></li>
      
    
  </div>
</div>
              </div>
            
            </div>
            
          </div>
          

          
          <div class="row pt-3">
            <div class="col-md-6">
              
                <a href=https://nowglow.github.io/blog/2019-06/spring%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%A4%A9/ class="post-meta">Previous
                  <div class="pt-2 pb-5 d-flex">
                    <i class="fas fa-angle-left text-grey font-weight-bold mr-2 active-color"></i>
                    <span>spring学习第三天</span>
                  </div>
                </a>
              
            </div>
            
            <div class="col-md-6 text-right" >
              
                <a href=https://nowglow.github.io/blog/2019-07/java%E8%BF%9B%E9%98%B6%E4%B9%A6%E7%B1%8D/ class="post-meta">Next
                  <div class="pt-2 pb-5 flex-reverse">
                    <i class="fas fa-angle-right text-grey font-weight-bold ml-2 active-color"></i>
                    <span>Java进阶书籍</span>
                  </div>
                </a>
              
            </div>
          </div>

          

        </div>
        

      </div>
      

      
	
	
	
	
		
		
		
	

		
		<div class="col-md-2 pl-0">

			
			<div id="page-scrollspy" class="toc-nav">
				
				<ul class="nav nav-pills ml-0">
					
					<li class="nav-item pb-3 text-center">
						<span class="font-weight-bold mb-2">- CATALOG - </span>
					</li>

					
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#aop%e7%9a%84%e6%a6%82%e8%bf%b0">
												 AOP的概述
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e4%bb%80%e4%b9%88%e6%98%afaop">
												 什么是AOP
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#aop%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86">
												 AOP底层原理
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#spring%e7%9a%84aop%e4%bb%a3%e7%90%86">
												 Spring的AOP代理
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#aop%e7%9a%84%e6%9c%af%e8%af%ad">
												 AOP的术语
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#aop%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0">
												 AOP的底层实现
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#jdk%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86">
												 JDK动态代理
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#cglib%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86">
												 CGLIB动态代理
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e4%bb%a3%e7%90%86%e7%9f%a5%e8%af%86%e6%80%bb%e7%bb%93">
												 代理知识总结
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#spring%e4%b8%ad%e7%9a%84aop">
												 Spring中的AOP
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#spring%e7%9a%84%e4%bc%a0%e7%bb%9faop">
												 Spring的传统AOP
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#spring%e4%b8%ad%e7%9a%84%e9%80%9a%e7%9f%a5-%e5%a2%9e%e5%bc%ba%e7%b1%bb%e5%9e%8b">
												 Spring中的通知(增强类型)
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#spring%e4%b8%ad%e7%9a%84%e5%88%87%e9%9d%a2%e7%b1%bb%e5%9e%8b">
												 Spring中的切面类型
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#spring%e7%9a%84aop%e7%9a%84%e5%bc%80%e5%8f%91">
												 Spring的AOP的开发
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e9%92%88%e5%af%b9%e6%89%80%e6%9c%89%e6%96%b9%e6%b3%95%e7%9a%84%e5%a2%9e%e5%bc%ba-%e4%b8%8d%e5%b8%a6%e6%9c%89%e5%88%87%e7%82%b9%e7%9a%84%e5%88%87%e9%9d%a2">
												 针对所有方法的增强:(不带有切点的切面)
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%b8%a6%e6%9c%89%e5%88%87%e7%82%b9%e7%9a%84%e5%88%87%e9%9d%a2-%e9%92%88%e5%af%b9%e7%9b%ae%e6%a0%87%e5%af%b9%e8%b1%a1%e7%9a%84%e6%9f%90%e4%ba%9b%e6%96%b9%e6%b3%95%e8%bf%9b%e8%a1%8c%e5%a2%9e%e5%bc%ba">
												 带有切点的切面:(针对目标对象的某些方法进行增强)
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e8%87%aa%e5%8a%a8%e4%bb%a3%e7%90%86">
												 自动代理
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#beannameautoproxycreator-%e6%8c%89%e5%90%8d%e7%a7%b0%e7%94%9f%e6%88%90%e4%bb%a3%e7%90%86">
												 BeanNameAutoProxyCreator :按名称生成代理
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e4%bd%bf%e7%94%a8aspectj%e5%ae%9e%e7%8e%b0aop">
												 使用AspectJ实现AOP
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#aspectj%e8%a1%a8%e8%be%be%e5%bc%8f">
												 AspectJ表达式
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#aspectj%e7%9a%84%e9%80%9a%e7%9f%a5%e7%b1%bb%e5%9e%8b">
												 AspectJ的通知类型
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%9f%ba%e4%ba%8e%e6%b3%a8%e8%a7%a3%e6%96%b9%e5%bc%8f%e9%85%8d%e7%bd%ae%e5%88%87%e9%9d%a2">
												 基于注解方式配置切面
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%b8%b8%e8%a7%81%e5%88%87%e9%9d%a2%e7%b1%bb%e7%bc%96%e5%86%99">
												 常见切面类编写
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#before%e5%89%8d%e7%bd%ae%e9%80%9a%e7%9f%a5">
												 @Before前置通知
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#afterreturing-%e5%90%8e%e7%bd%ae%e9%80%9a%e7%9f%a5">
												 @AfterReturing 后置通知
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#around-%e7%8e%af%e7%bb%95%e9%80%9a%e7%9f%a5">
												 @Around 环绕通知
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#afterthrowing-%e6%8a%9b%e5%87%ba%e9%80%9a%e7%9f%a5">
												 @AfterThrowing 抛出通知
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#after-%e6%9c%80%e7%bb%88%e9%80%9a%e7%9f%a5">
												 @After 最终通知
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e9%80%9a%e8%bf%87-pointcut%e4%b8%ba%e5%88%87%e7%82%b9%e5%91%bd%e5%90%8d">
												 通过@Pointcut为切点命名
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e4%bd%bf%e7%94%a8xml%e9%85%8d%e7%bd%ae%e5%88%87%e9%9d%a2">
												 使用XML配置切面
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%89%8d%e7%bd%ae%e9%80%9a%e7%9f%a5">
												 前置通知
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%90%8e%e7%bd%ae%e9%80%9a%e7%9f%a5">
												 后置通知
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e7%8e%af%e7%bb%95%e9%80%9a%e7%9f%a5">
												 环绕通知
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%bc%82%e5%b8%b8%e9%80%9a%e7%9f%a5">
												 异常通知
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e6%9c%80%e7%bb%88%e9%80%9a%e7%9f%a5">
												 最终通知
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 

				</ul>
			</div>
			

		</div>
		
	

    </div>
    


  </main>
  


    
    

<footer class="page-footer text-center font-small mt-4 wow fadeIn">


  
  <div class="pb-2 mt-5 pt-5">
    
      <a href="//github.com/nowglow " target="_blank" rel="noopener"><i class="fab fa-github mr-3" aria-hidden="true"></i></a>    
    
    

    

    

    

    

    


    
        <a href="mailto:raopengyuan@aliyun.com"><i class="far fa-envelope-open mr-3" aria-hidden="true"></i></a>
    

    

    

  </div>
  

  
  <div class="copyright py-4">
    
    <span>  2016 - 2019 &copy; | Theme <a href='https://github.com/orianna-zzo/AllinOne' target="_blank">AllinOne</a> by <a href='https://github.com/orianna-zzo' target="_blank">Orianna</a>  </span>
  </div>
  

</footer>


    






<script type="text/javascript" src="https://nowglow.github.io/js/vendors/jquery/jquery-3.3.1.min.js"></script>
<script type="text/javascript" src="https://nowglow.github.io/js/vendors/jquery/jquery.smooth-scroll.min.js"></script>



<script type="text/javascript" src="https://nowglow.github.io/js/vendors/popper.min.js"></script>
<script type="text/javascript" src="https://nowglow.github.io/js/vendors/holder.min.js"></script>
<script type="text/javascript" src="https://nowglow.github.io/js/vendors-extensions/bootstrap4/bootstrap.js" ></script>

<script type="text/javascript" src="https://nowglow.github.io/js/vendors/mdb/mdb.min.js"></script>

<script type="text/javascript" src="https://nowglow.github.io/js/main.js"></script>



  
  <script src="https://nowglow.github.io/js/vendors/highlight.pack.js"> </script>
  <script>hljs.initHighlightingOnLoad();</script>




 
  <script src="https://nowglow.github.io/js/vendors/katex/katex.min.js"> </script>
  <script src="https://nowglow.github.io/js/vendors/katex/contrib/auto-render.min.js"></script>

  <script>
      document.addEventListener("DOMContentLoaded", function () {
          renderMathInElement(document.body);
      });
  </script>








<script type="text/javascript">
  
  new WOW().init();
</script>




  </body>
</html>